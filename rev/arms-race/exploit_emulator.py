from unicorn import *
from unicorn.arm_const import *
import socket
import re
import sys

def emulate_arm32(binary):
	BASE_ADDRESS = 0
	try:
		# Initialize emulator in ARM mode
		mu = Uc(UC_ARCH_ARM, UC_MODE_ARM)
		# map 2MB memory for this emulation
		mu.mem_map(BASE_ADDRESS, 2 * 1024 * 1024)
		# write machine code to be emulated to memory
		mu.mem_write(BASE_ADDRESS, binary)

		# initialize machine registers
		mu.reg_write(UC_ARM_REG_R0, 0)
		mu.reg_write(UC_ARM_REG_R1, 0)
		mu.reg_write(UC_ARM_REG_R2, 0)
		mu.reg_write(UC_ARM_REG_R3, 0)
		mu.emu_start(BASE_ADDRESS, BASE_ADDRESS + len(binary))

		r0 = mu.reg_read(UC_ARM_REG_R0)
		return '0x%x' % r0
	except UcError as e:
		print("ERROR: %s" % e)

HOST ="83.136.249.57"
PORT = 56087
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
	s.connect((HOST, PORT))
	for i in range(51):
		buff = b''
		while not buff.decode().endswith('Register r0:  '): # sometimes the whole message is not received at once in the socket
			buff += s.recv(2**12)
			if buff.decode() == 'Wrong answer\n': break
			if buff.decode().startswith('HTB'): print(buff.decode()); sys.exit(0)
		print(buff.decode()[:11])
		match = re.findall(r'Level \d+/\d+: ([^\n]+)', buff.decode())
		if len(match) == 0: print(buff.decode()); break
		res = emulate_arm32(bytes.fromhex(match[0]))
		s.sendall(f'{res}\n'.encode())

# with open('dump', 'rb') as fd:
# 	print(emulate_arm32(fd.read()))

